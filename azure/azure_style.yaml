parameters:
  - name: REPO_NAME
    type: string
  - name: IMAGE
    type: string
  # The following parameters have defaults because this template could be used by repos directly
  - name: TIMEOUT
    type: number
    default: 10
  - name: IGNORE_STYLE
    type: boolean
    default: false
  - name: BASE_FORMAT_AND_LINT
    type: boolean
    default: true
  - name: ISORT
    type: boolean
    default: false
  - name: PYLINT
    type: boolean
    default: false
  - name: CLANG_FORMAT
    type: boolean
    default: false
  - name: FPRETTIFY
    type: boolean
    default: false
  - name: MYPY
    type: boolean
    default: false
jobs:
  - job: base_format_and_lint
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.BASE_FORMAT_AND_LINT }}
    steps:
      - checkout: self
      - checkout: azure_template
      - task: UsePythonVersion@0
        inputs:
          versionSpec: "3.11"
      - script: |
          cd ${{ parameters.REPO_NAME }}
          cp ../.github/.pre-commit-config.yaml .
          pip install pre-commit

          # Set the ruff config in the .github repo as the global config, then the local config should extend it by including the line `extend = "~/.config/ruff/ruff.toml"`
          mkdir -p ~/.config/ruff
          cp ../.github/ruff.toml ~/.config/ruff/ruff.toml

          echo "Ruff config:"
          cat ~/.config/ruff/ruff.toml
          if [[ -f "ruff.toml" ]]; then
              cat ruff.toml
          fi

          # Run the pre-commit checks
          pre-commit run --all-files --show-diff-on-failure

  - job: isort
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.ISORT }}
    steps:
      - checkout: self
      - checkout: azure_template
      - task: UsePythonVersion@0
        inputs:
          versionSpec: "3.11"
      - script: |
          cd ${{ parameters.REPO_NAME }}

          # copy over the isort config file
          if [[ ! -f ".isort.cfg" ]]; then
            cp ../.github/.isort.cfg .
          fi

          pip install wheel
          pip install isort
          isort . -c

  - job: pylint
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.PYLINT }}
    steps:
      - checkout: self
      - checkout: azure_template
      - task: UsePythonVersion@0
        inputs:
          versionSpec: "3.11"
      - script: |
          cd ${{ parameters.REPO_NAME }}

          # copy over the pylint config file
          cp ../.github/.pylintrc .

          pip install pylint
          find . -type f -name "*.py" -not -path "*/doc/*" | xargs pylint

  - job: clang_format
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.CLANG_FORMAT }}
    steps:
      - checkout: self
      - checkout: azure_template
      - script: |
          # Install prerequisites
          sudo apt-get install clang-format-10 -y

          cd ${{ parameters.REPO_NAME }}

          # Check if we can access script, if not exit
          if [[ ! -f ../.github/azure/clang-format.sh ]]; then
            echo "clang-format.sh not found. Exiting."
            exit 1
          fi

          # Run the formatting
          bash ../.github/azure/clang-format.sh --dry-run || exit $?

  - job: fprettify
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.FPRETTIFY }}
    steps:
      - checkout: self
      - checkout: azure_template
      - task: UsePythonVersion@0
        inputs:
          versionSpec: "3.11"
      - script: |
          cd ${{ parameters.REPO_NAME }}

          # Check if we can access script, if not exit
          if [[ ! -f ../.github/azure/fprettify.sh ]]; then
            echo "fprettify.sh not found. Exiting."
            exit 1
          fi

          # Install fprettify
          pip install fprettify==0.3.7

          # Run the formatting
          bash ../.github/azure/fprettify.sh || exit $?

          # Exit with an error if any of the tracked files changed
          git diff --summary --exit-code

  - job: mypy
    pool:
      vmImage: "ubuntu-22.04"
    timeoutInMinutes: ${{ parameters.TIMEOUT }}
    continueOnError: ${{ parameters.IGNORE_STYLE }}
    condition: ${{ parameters.MYPY }}
    strategy:
      matrix:
        "u24-gcc-ompi-latest":
          DOCKER_TAG: u24-gcc-ompi-latest
    variables:
      - group: Docker
      - name: SCRITICAL_HOMEDIR
        value: /home/scriticaluser
      - name: DOCKER_WORKING_DIR
        value: ${{ variables.SCRITICAL_HOMEDIR }}/repos/${{ parameters.REPO_NAME }}
      - name: DOCKER_MOUNT_DIR
        value: ${{ variables.SCRITICAL_HOMEDIR }}/azure/${{ parameters.REPO_NAME }}
      - name: BASHRC
        value: ${{ variables.SCRITICAL_HOMEDIR }}/.bashrc_scritical
    steps:
      - checkout: self
      - checkout: azure_template
      - task: UsePythonVersion@0
        inputs:
          versionSpec: "3.11"
      - script: |
          # This is a trusted build if DOCKER_USERNAME is defined
          if [[ ! -z $(DOCKER_USERNAME) ]] ; then
            echo $(DOCKER_PASSWORD) | docker login -u $(DOCKER_USERNAME) --password-stdin;
          fi
          # "auto" pulls the private image for trusted builds
          if [[ "${{ parameters.IMAGE }}" == "private" ]] || [[ "${{ parameters.IMAGE }}" == "auto" && ! -z $(DOCKER_USERNAME) ]] ; then
            export DOCKER_IMAGE=private-dev;
          else
            export DOCKER_IMAGE=public-dev;
          fi
          docker pull scritical/$DOCKER_IMAGE:$(DOCKER_TAG);
          docker run -t -d --name app --mount "type=bind,src=$(pwd)/${{ parameters.REPO_NAME }},target=${{ variables.DOCKER_MOUNT_DIR }}" scritical/$DOCKER_IMAGE:$(DOCKER_TAG) /bin/bash;
          docker exec app /bin/bash -c "rm -rf ${{ variables.DOCKER_WORKING_DIR }} && cp -r ${{ variables.DOCKER_MOUNT_DIR }} ${{ variables.DOCKER_WORKING_DIR }}";
        displayName: Prepare Repository
      - script: |
          set -e
          docker exec app /bin/bash -c ". ${{ variables.BASHRC }} && cd ${{ variables.DOCKER_WORKING_DIR }} && mypy"
        displayName: Run mypy
        condition: and(succeeded())


